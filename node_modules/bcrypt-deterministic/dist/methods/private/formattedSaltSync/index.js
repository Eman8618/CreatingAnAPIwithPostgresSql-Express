"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_1 = __importDefault(require("crypto"));
// Bindings
var bindings_1 = require("../../../bindings");
var MINOR = new Set(['a', 'b']);
exports.default = (function (_a) {
    var _b = _a === void 0 ? {} : _a, salt = _b.salt, _c = _b.rounds, rounds = _c === void 0 ? 10 : _c, _d = _b.minor, minor = _d === void 0 ? 'b' : _d;
    if (salt && typeof salt !== 'string')
        throw new Error("bcrypt.formattedSalt \"salt\" must be a string.");
    if (typeof rounds != 'number')
        throw new Error("bcrypt.formattedSalt \"rounds\" must be a number. Provided value was \"" + rounds + "\"");
    if (!MINOR.has(minor))
        throw new Error("bcrypt.formattedSalt \"minor\" must be one of the following values " + Array.from(MINOR).join(', ') + ", received \"" + minor + "\".");
    var saltHash;
    // Create a 16 byte hash from the provided salt.
    if (salt) {
        var hash = crypto_1.default.createHash('sha512');
        hash.update(salt);
        // Digest and truncate the hash to 16 bytes.
        saltHash = hash.digest().slice(0, 16);
    }
    // Generate random 16 bytes if no salt provided.
    else {
        saltHash = crypto_1.default.randomBytes(16);
    }
    return bindings_1.bindings.gen_salt_sync(minor, rounds, saltHash);
});
//# sourceMappingURL=index.js.map